<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Runner - ì²´ìœ¡ í€´ì¦ˆ ì—ë””ì…˜</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #111;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', Courier, monospace;
            color: white;
            user-select: none;
            touch-action: none; 
        }

        #gameContainer {
            position: relative;
            width: 800px;
            height: 450px;
            
            /* [Feature] 3. ì€ìƒ‰ í…Œë‘ë¦¬ (ê²Œì„ê¸° ë² ì ¤ íš¨ê³¼) */
            border: 20px solid #C0C0C0; /* ì€ìƒ‰ */
            border-radius: 15px; /* ë‘¥ê·¼ ëª¨ì„œë¦¬ */
            /* ì…ì²´ê°ì„ ìœ„í•œ ê·¸ë¦¼ì íš¨ê³¼ */
            box-shadow: 
                inset 5px 5px 10px rgba(255,255,255,0.7), /* ì•ˆìª½ í•˜ì´ë¼ì´íŠ¸ */
                inset -5px -5px 15px rgba(0,0,0,0.5),    /* ì•ˆìª½ ê·¸ë¦¼ì */
                0 20px 50px rgba(0,0,0,0.8);             /* ë°”ê¹¥ ê·¸ë¦¼ì */
            background: #000;
            box-sizing: content-box; /* í…Œë‘ë¦¬ê°€ ë‚´ìš©ë¬¼ í¬ê¸° ë°–ì— ìœ„ì¹˜ */
            z-index: 1;
            max-width: 100%; /* ë°˜ì‘í˜• ëŒ€ì‘ */
        }

        canvas {
            display: block;
            background-color: #87CEEB; 
            /* í”½ì…€ ì•„íŠ¸ê°€ íë¦¿í•´ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
            image-rendering: pixelated; 
            width: 100%;
            height: 100%;
            border-radius: 5px; /* ë‚´ë¶€ í™”ë©´ë„ ì‚´ì§ ë‘¥ê¸€ê²Œ */
        }

        #uiLayer {
            position: absolute;
            top: 15px;
            left: 20px;
            width: 95%;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
        }

        .hud-text {
            font-family: 'Press Start 2P', cursive;
            font-size: 18px;
            color: #fff;
            text-shadow: 3px 3px 0 #000;
        }

        /* í„°ì¹˜ ì»¨íŠ¸ë¡¤ëŸ¬ */
        #touchControls {
            display: flex;
            width: 100%;
            max-width: 800px;
            justify-content: space-between;
            margin-top: 20px; 
            padding: 0 20px;
            box-sizing: border-box;
        }

        .control-btn {
            width: 120px;
            height: 80px;
            background-color: #333;
            border: 4px solid #666;
            border-radius: 15px;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
            box-shadow: 0 5px 0 #000;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .control-btn:active, .control-btn.active {
            transform: translateY(5px);
            box-shadow: 0 0 0 #000;
            background-color: #555;
            border-color: #888;
        }

        .btn-jump { background-color: #d32f2f; border-color: #b71c1c; }
        .btn-slide { background-color: #1976d2; border-color: #0d47a1; }

        #startScreen, #endScreen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 100;
            font-family: 'Press Start 2P', cursive;
            border-radius: 5px;
        }

        .retro-title {
            font-size: 50px;
            color: #ff0055;
            text-shadow: 4px 4px #00eaff;
            margin-bottom: 40px;
            animation: titleFloat 2s infinite ease-in-out;
            line-height: 1.5;
        }

        .retro-desc {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 10px;
            line-height: 1.8;
        }

        .press-start {
            margin-top: 20px;
            font-size: 20px;
            color: #ffff00;
            animation: blink 0.8s infinite;
            cursor: pointer;
            border: 2px solid #ffff00;
            padding: 15px 30px;
            background: transparent;
            font-family: inherit;
        }
        .press-start:hover { background: #ffff00; color: #000; }

        @keyframes blink { 50% { opacity: 0; } }
        @keyframes titleFloat { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }

        .hidden { display: none !important; }

        #quizModal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 700px; max-width: 90%; background: rgba(0, 0, 0, 0.95);
            border: 4px solid #4CAF50; border-radius: 0;
            padding: 30px; text-align: center; color: white;
            display: none; z-index: 200;
            box-shadow: 8px 8px 0px rgba(0,0,0,0.5);
            font-family: 'Courier New', monospace;
        }
        #quizModal h2 { margin-top: 0; color: #4CAF50; font-family: 'Press Start 2P', cursive; font-size: 20px; margin-bottom: 20px; }
        #questionText { font-size: 20px; margin: 20px 0; font-weight: bold; line-height: 1.4; word-break: keep-all; }
        .options { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .option-btn {
            background: #333; border: 2px solid #fff; color: white;
            padding: 15px; font-size: 16px; cursor: pointer;
            transition: 0.1s; font-family: inherit; word-break: keep-all;
        }
        .option-btn:hover { background: #fff; color: #000; transform: scale(1.02); }

        #feedbackMsg {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            font-size: 40px; font-weight: bold; text-shadow: 4px 4px 0 #000;
            display: none; z-index: 300; pointer-events: none;
            white-space: nowrap;
            font-family: 'Press Start 2P', cursive;
        }
        @keyframes popUp { 
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.0); opacity: 0; }
        }
        
        #quizProgress {
            position: absolute; top: 50px; left: 20px;
            font-family: 'Press Start 2P'; font-size: 12px; color: #aaa;
        }

        /* í€´ì¦ˆ ê²°ê³¼ ë¦¬í¬íŠ¸ ìŠ¤íƒ€ì¼ */
        #quizReport {
            margin-bottom: 20px;
            width: 80%;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: left;
            max-height: 200px;
            overflow-y: auto;
            border: 2px solid #555;
        }
        .report-item {
            font-size: 12px;
            margin-bottom: 8px;
            border-bottom: 1px solid #444;
            padding-bottom: 4px;
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: space-between;
        }
        .report-correct { color: #4CAF50; }
        .report-wrong { color: #ff4444; }
        .report-summary {
            font-size: 14px;
            margin-bottom: 15px;
            color: #fff;
            text-align: center;
            font-weight: bold;
        }
    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="450"></canvas>
    
    <div id="uiLayer">
        <span id="scoreDisplay" class="hud-text">SCORE: 0</span>
        <span id="livesDisplay" class="hud-text">â¤ï¸â¤ï¸â¤ï¸â¤ï¸â¤ï¸</span>
    </div>
    <div id="quizProgress">QUIZ: 0/10</div>

    <div id="quizModal">
        <h2 id="quizTitle">BONUS QUIZ</h2>
        <div id="questionText"></div>
        <div class="options" id="quizOptions"></div>
    </div>

    <div id="feedbackMsg"></div>

    <div id="startScreen">
        <div class="retro-title">PIXEL<br>RUNNER</div>
        <div class="retro-desc">
            <span style="color:#4CAF50;">4í•™ë…„ ì²´ìœ¡: ê²½ìŸ & í‘œí˜„</span><br><br>
            PC: SPACE / DOWN<br>
            TABLET: USE BUTTONS BELOW
        </div>
        <button class="press-start" onclick="startGame()">PRESS START</button>
    </div>

    <div id="endScreen" class="hidden">
        <h1 id="endTitle" style="color:#ff4444; margin-bottom:10px; margin-top: 10px;">GAME OVER</h1>
        <p id="finalScore" style="margin-bottom:15px; font-size: 20px;">SCORE: 0</p>
        
        <!-- í€´ì¦ˆ ê²°ê³¼ ë¦¬í¬íŠ¸ ì˜ì—­ -->
        <div id="quizReport">
            <div class="report-summary">ê²°ê³¼ë¥¼ ì§‘ê³„ ì¤‘...</div>
            <!-- ìƒì„¸ ëª©ë¡ì´ ì—¬ê¸°ì— ë“¤ì–´ê°‘ë‹ˆë‹¤ -->
        </div>

        <button class="press-start" onclick="resetGame()">TRY AGAIN</button>
    </div>
</div>

<div id="touchControls">
    <div class="control-btn btn-slide" id="btnSlide">SLIDE</div>
    <div class="control-btn btn-jump" id="btnJump">JUMP</div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // ===================================================
    // ğŸµ BGM ë° ì‚¬ìš´ë“œ ì‹œìŠ¤í…œ (Web Audio API)
    // ===================================================
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();

    const NOTE_FREQS = {
        C4: 261.63, D4: 293.66, E4: 329.63, F4: 349.23, G4: 392.0,
        A4: 440.0, B4: 493.88,
        C5: 523.25, D5: 587.33, E5: 659.25, F5: 698.46, G5: 783.99,
        A5: 880.0
    };

    // [BGM 1] ìˆ² ëŸ¬ë„ˆ íŠ¸ë™
    const FOREST_TRACK = {
        tempo: 160,
        notes: [
            [NOTE_FREQS.C4, 0.5], [NOTE_FREQS.E4, 0.5], [NOTE_FREQS.G4, 0.5], [NOTE_FREQS.E4, 0.5],
            [NOTE_FREQS.C4, 0.5], [NOTE_FREQS.E4, 0.5], [NOTE_FREQS.G4, 0.5], [NOTE_FREQS.C5, 0.5],
            [NOTE_FREQS.F4, 0.5], [NOTE_FREQS.A4, 0.5], [NOTE_FREQS.C5, 0.5], [NOTE_FREQS.A4, 0.5],
            [NOTE_FREQS.G4, 0.5], [NOTE_FREQS.E4, 0.5], [NOTE_FREQS.D4, 0.5], [NOTE_FREQS.E4, 0.5],
            [NOTE_FREQS.C4, 1],   [NOTE_FREQS.G4, 1],
            [NOTE_FREQS.E4, 0.5], [NOTE_FREQS.F4, 0.5], [NOTE_FREQS.E4, 0.5], [NOTE_FREQS.D4, 0.5],
            [NOTE_FREQS.C4, 1]
        ]
    };

    // [BGM 2] ë³´ìŠ¤ì „ íŠ¸ë™
    const BOSS_TRACK = {
        tempo: 240,
        notes: [
            [NOTE_FREQS.A4, 0.5], [NOTE_FREQS.A4, 0.5], [NOTE_FREQS.C5, 0.5], [NOTE_FREQS.A4, 0.5],
            [NOTE_FREQS.D5, 0.5], [NOTE_FREQS.A4, 0.5], [NOTE_FREQS.E5, 0.5], [NOTE_FREQS.D5, 0.5],
            [NOTE_FREQS.C5, 0.5], [NOTE_FREQS.C5, 0.5], [NOTE_FREQS.E5, 0.5], [NOTE_FREQS.C5, 0.5],
            [NOTE_FREQS.G5, 0.5], [NOTE_FREQS.E5, 0.5], [NOTE_FREQS.A5, 1],
            [NOTE_FREQS.G4, 0.5], [NOTE_FREQS.G4, 0.5], [NOTE_FREQS.B4, 0.5], [NOTE_FREQS.G4, 0.5],
            [NOTE_FREQS.A4, 2]
        ]
    };

    let isForestBGMPlaying = false;
    let forestTimerID;
    let forestNextNoteTime = 0;
    let forestCurrentNoteIndex = 0;

    let isBossBGMPlaying = false;
    let bossTimerID;
    let bossNextNoteTime = 0;
    let bossCurrentNoteIndex = 0;

    function playOscillator(freq, time, duration) {
        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        osc.type = "square";
        osc.frequency.setValueAtTime(freq, time);
        gainNode.gain.setValueAtTime(0.03, time);
        gainNode.gain.exponentialRampToValueAtTime(0.004, time + duration * 0.9);
        osc.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        osc.start(time);
        osc.stop(time + duration);
    }

    function forestScheduler() {
        if (!isForestBGMPlaying) return;
        while (forestNextNoteTime < audioCtx.currentTime + 0.1) {
            const note = FOREST_TRACK.notes[forestCurrentNoteIndex];
            const duration = note[1] * (60.0 / FOREST_TRACK.tempo);
            playOscillator(note[0], forestNextNoteTime, duration);
            forestNextNoteTime += duration;
            forestCurrentNoteIndex++;
            if (forestCurrentNoteIndex >= FOREST_TRACK.notes.length) forestCurrentNoteIndex = 0;
        }
        forestTimerID = setTimeout(forestScheduler, 25);
    }

    function bossScheduler() {
        if (!isBossBGMPlaying) return;
        while (bossNextNoteTime < audioCtx.currentTime + 0.1) {
            const note = BOSS_TRACK.notes[bossCurrentNoteIndex];
            const duration = note[1] * (60.0 / BOSS_TRACK.tempo);
            playOscillator(note[0], bossNextNoteTime, duration);
            bossNextNoteTime += duration;
            bossCurrentNoteIndex++;
            if (bossCurrentNoteIndex >= BOSS_TRACK.notes.length) bossCurrentNoteIndex = 0;
        }
        bossTimerID = setTimeout(bossScheduler, 25);
    }

    function playForestRunnerBGM() {
        stopBossBattleBGM();
        if (isForestBGMPlaying) return;
        forestCurrentNoteIndex = 0;
        forestNextNoteTime = audioCtx.currentTime + 0.1;
        isForestBGMPlaying = true;
        forestScheduler();
    }

    function stopForestRunnerBGM() {
        isForestBGMPlaying = false;
        if (forestTimerID) clearTimeout(forestTimerID);
    }

    function playBossBattleBGM() {
        stopForestRunnerBGM();
        if (isBossBGMPlaying) return;
        bossCurrentNoteIndex = 0;
        bossNextNoteTime = audioCtx.currentTime + 0.1;
        isBossBGMPlaying = true;
        bossScheduler();
    }

    function stopBossBattleBGM() {
        isBossBGMPlaying = false;
        if (bossTimerID) clearTimeout(bossTimerID);
    }

    // íš¨ê³¼ìŒ í•¨ìˆ˜
    function playSound(type) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        osc.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        const now = audioCtx.currentTime;
        
        try {
            if (type === 'jump') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
                gainNode.gain.setValueAtTime(0.05, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'stomp') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(150, now + 0.15); 
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
            } else if (type === 'hit') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.linearRampToValueAtTime(50, now + 0.3);
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (type === 'coin') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(987.77, now); // B5
                osc.frequency.setValueAtTime(1318.51, now + 0.08); // E6
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            }
        } catch(e) { console.error(e); }
    }
    
    ['keydown', 'mousedown', 'touchstart'].forEach(event => {
        window.addEventListener(event, () => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }, { once: true });
    });
    // ----------------------------------

    const GAME_WIDTH = 800;
    const GAME_HEIGHT = 450;
    const GROUND_Y = 415; 
    const GRAVITY = 0.6;
    const MAX_QUIZ_COUNT = 10; 
    
    let gameSpeed = 5;
    let score = 0;
    let lives = 5;
    let isGameOver = false;
    let isPlaying = false;
    let isPaused = false; 
    let lastQuizTime = 0;
    let quizCount = 0; 
    let quizResults = []; // í€´ì¦ˆ ê²°ê³¼ ì €ì¥ìš© ë°°ì—´

    const charImg = new Image();
    charImg.src = "https://postfiles.pstatic.net/MjAyNTExMjVfMTY5/MDAxNzY0MDQxMzI4MjIw.0qg3Ba7QymhoKYl6oFLh_1y4FjbrsifhLYenU7Pi_Eog.ScRyb20ebotqHukwCt9nnY4AHO9oO-t-N5sIKb4-_aEg.PNG/Gemini_Generated_Image_hav6ukhav6ukhav6-removebg-preview.png?type=w966"; 

    const bgImg = new Image();
    bgImg.src = "https://postfiles.pstatic.net/MjAyNTExMjVfMTU0/MDAxNzY0MDQxMzQzMTc4.RBg5swSFhJva6iRkhN9trZhf1hZmjd0vwiBAN6RCziAg.GoAyVUDx1u_bnl4-dPpqyfcG5NWHa-O_6SJ8IC0fM9Ug.PNG/Gemini_Generated_Image_q7j8idq7j8idq7j8.png?type=w966";

    const enemyImg = new Image();
    enemyImg.src = "https://postfiles.pstatic.net/MjAyNTExMjVfNzUg/MDAxNzY0MDQxMzM3NDg1.t5MxCquZnN-czOHhMXUEuphRbQQe2ktJqmnKEDuWNE0g.tqfy5gDRpBAQbRAahEKI_q5uADtXZJ3_70rA4MCGhpIg.PNG/Gemini_Generated_Image_dvf80edvf80edvf8-removebg-preview.png?type=w966";

    const airObsImg = new Image();
    airObsImg.src = "https://postfiles.pstatic.net/MjAyNTExMjVfODcg/MDAxNzY0MDQxMzMyNjgw.nBEIKFRcM41eJbKtExRnnSH2VJMcsUzUYXbmCUAsL6Ag.HPwIcQZj8Sjg4EC1pm_2tOxQlIcVPqo_GrIXh2rpd5Qg.PNG/Gemini_Generated_Image_oz4wv6oz4wv6oz4w-removebg-preview.png?type=w966";

    const bossImg = new Image();
    bossImg.src = "https://postfiles.pstatic.net/MjAyNTExMjVfMjA4/MDAxNzY0MDQxMzMwNzYz.lOHVTpqvhoHw7OkFiVVaKXuCRSocvHAaunw65BnlXxUg.YN-hXne9Jgf_gCX6Ps464IUWHBsgQldwZnoSXLKWb4Qg.PNG/Gemini_Generated_Image_d7101qd7101qd710-removebg-preview.png?type=w966";

    // í€´ì¦ˆ ë°ì´í„° (ì²´ìœ¡ 4í•™ë…„: ê²½ìŸ-í‹°ë³¼/í‘œí˜„)
    const QUIZ_DATA = [
      { q: "ë©€ë¦¬ ìˆëŠ” ì¹œêµ¬ì—ê²Œ ê³µì„ ë¹ ë¥´ê³  ê°•í•˜ê²Œ ë˜ì ¸ì•¼ í•  ë•Œ, ê°€ì¥ ì•Œë§ì€ ë°©ë²•ì€?", o: ["ì–¸ë”í•¸ë“œ ìŠ¤ë¡œ", "ì˜¤ë²„í•¸ë“œ ìŠ¤ë¡œ", "ì‚¬ì´ë“œì•” ìŠ¤ë¡œ", "ì²´ìŠ¤íŠ¸ íŒ¨ìŠ¤"], a: 1 },
      { q: "ë‹¤ìŒ ì¤‘ 'ì–¸ë”í•¸ë“œ ìŠ¤ë¡œ'ì— ëŒ€í•œ ì„¤ëª…ìœ¼ë¡œ ì˜³ì€ ê²ƒì€?", o: ["ê°€ì¥ ë©€ë¦¬ ë˜ì§ˆ ë•Œ ì“´ë‹¤", "ì–´ê¹¨ ìœ„ë¡œ ë˜ì§„ë‹¤", "ê°€ê¹Œìš´ ê³³ì— ë¶€ë“œëŸ½ê²Œ ë˜ì§ˆ ë•Œ ì“´ë‹¤", "ë³€í™”êµ¬ë¥¼ ë˜ì§ˆ ë•Œë§Œ ì“´ë‹¤"], a: 2 },
      { q: "í‹°ë³¼ ìˆ˜ë¹„ ì¤‘ ì£¼ìë¥¼ ì•„ì›ƒì‹œí‚¤ê¸° ìœ„í•´ 1ë£¨ë¡œ ë¹ ë¥´ê²Œ ì†¡êµ¬í•˜ë ¤ í•œë‹¤. ê°€ì¥ ì ì ˆí•œ ë°©ë²•ì€?", o: ["ì˜¤ë²„í•¸ë“œ ìŠ¤ë¡œë¡œ ê°•í•˜ê²Œ", "ì–¸ë”í•¸ë“œ ìŠ¤ë¡œë¡œ ì‚´ì‚´", "ì•„ë¬´ë ‡ê²Œë‚˜", "í•˜ëŠ˜ ë†’ì´ ë˜ì§„ë‹¤"], a: 0 },
      { q: "ìƒˆë¡œìš´ ê³µ ë˜ì§€ê¸° ê¸°ìˆ ì„ ë°°ìš¸ ë•Œ ê°€ì¥ ë°”ëŒì§í•œ íƒœë„ëŠ”?", o: ["ì‹¤íŒ¨í• ê¹Œ ë´ ì•ˆ í•œë‹¤", "ë‚´ ë§˜ëŒ€ë¡œ í•œë‹¤", "ìì‹ ê°ì„ ê°–ê³  ì ê·¹ì ìœ¼ë¡œ í•œë‹¤", "ìˆ¨ì–´ì„œ í•œë‹¤"], a: 2 },
      { q: "ê³µ ë˜ì§€ê¸° ë°©ë²•ì— ëŒ€í•œ ì„¤ëª…ìœ¼ë¡œ í‹€ë¦° ê²ƒì€?", o: ["ì˜¤ë²„í•¸ë“œëŠ” ë©€ë¦¬ ë˜ì§ˆ ë•Œ ìœ ë¦¬", "ì–¸ë”í•¸ë“œëŠ” ì •í™•íˆ ë˜ì§ˆ ë•Œ ìœ ë¦¬", "ì‚¬ì´ë“œì•”ì€ ì˜†ìœ¼ë¡œ ë˜ì§„ë‹¤", "ëª¨ë“  ìƒí™©ì—ì„œ í•œ ê°€ì§€ë§Œ ì“´ë‹¤"], a: 3 },
      { q: "ë‹¤ìŒ ì¤‘ ëª¸ì˜ ìœ„ì¹˜ë¥¼ ì˜®ê¸°ëŠ” 'ì´ë™ ì›€ì§ì„'ì€?", o: ["ì œìë¦¬ íŒ” ë»—ê¸°", "ì•‰ì•˜ë‹¤ ì¼ì–´ì„œê¸°", "ì•ìœ¼ë¡œ ë‹¬ë ¤ê°€ê¸°", "í—ˆë¦¬ êµ½í˜€ ì¸ì‚¬í•˜ê¸°"], a: 2 },
      { q: "ë‹¤ìŒ ì¤‘ ì œìë¦¬ì—ì„œ í•˜ëŠ” 'ë¹„ì´ë™ ì›€ì§ì„'ì´ ì•„ë‹Œ ê²ƒì€?", o: ["ê· í˜• ì¡ê¸°", "ëª¸ ë¹„í‹€ê¸°", "ì œìë¦¬ ë†’ì´ ë›°ê¸°", "ì¹œêµ¬ ì†ì¡ê³  ëŒë©° ì´ë™í•˜ê¸°"], a: 3 },
      { q: "ë„êµ¬ë¥¼ ì‚¬ìš©í•˜ëŠ” 'ì¡°ì‘ ì›€ì§ì„'ì— í•´ë‹¹í•˜ëŠ” ê²ƒì€?", o: ["ë…¸ë˜í•˜ë©° ê±·ê¸°", "ë°œë¡œ ê³µ ì°¨ê¸°", "ì¶¤ì¶”ê¸°", "ì¤€ë¹„ ì²´ì¡°í•˜ê¸°"], a: 1 },
      { q: "ì œìë¦¬ì—ì„œ ë‚˜ë¹„ì²˜ëŸ¼ íŒ”ì„ í”ë“œëŠ” ë™ì‘ì€ ì–´ë–¤ ì›€ì§ì„ì¼ê¹Œ?", o: ["ì´ë™ ì›€ì§ì„", "ë¹„ì´ë™ ì›€ì§ì„", "ì¡°ì‘ ì›€ì§ì„", "ë³µí•© ì›€ì§ì„"], a: 1 },
      { q: "'ë‹¬ë ¤ê°€ë©´ì„œ(ã„±) ê³µì„ ë°›ëŠ”(ã„´)' ë™ì‘ì˜ ì˜¬ë°”ë¥¸ ì—°ê²°ì€?", o: ["ã„±:ë¹„ì´ë™, ã„´:ì¡°ì‘", "ã„±:ì´ë™, ã„´:ë¹„ì´ë™", "ã„±:ì´ë™, ã„´:ì¡°ì‘", "ã„±:ì¡°ì‘, ã„´:ì´ë™"], a: 2 }
    ];

    const keys = { ArrowDown: false, Space: false };

    class Particle {
        constructor(x, y, size, color) {
            this.x = x; this.y = y; this.size = size; this.color = color;
            this.speedX = Math.random() * 3 - 1.5;
            this.speedY = Math.random() * 3 - 1.5; 
        }
        update() {
            this.x += this.speedX; this.y += this.speedY; this.size -= 0.15; 
        }
        draw(ctx) {
            if (this.size <= 0) return; 
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
            ctx.fill();
        }
    }

    let particles = [];
    function createParticles(x, y, count, color) {
        for(let i=0; i<count; i++) {
            particles.push(new Particle(x, y, Math.random()*5+3, color));
        }
    }

    class Sprite {
        constructor(image) { this.image = image; }
        draw(ctx, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {
            if (this.image.complete && this.image.naturalWidth > 0) {
                ctx.drawImage(this.image, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
            }
        }
    }

    class Player {
        constructor() {
            this.x = 100; this.y = GROUND_Y; this.vy = 0; this.scale = 1.0; 
            this.state = 'run'; this.isGrounded = true; this.jumpCount = 0;
            this.invincible = false; this.invincibleTimer = 0;
            this.frameX = 0; this.fps = 10; this.frameInterval = 1000 / this.fps; this.frameTimer = 0;

            this.animConfig = {
                run:   { sy: 0,   w: 76,  h: 76,  oy: -77, maxFrame: 6, paddingX: 0, paddingY: 0 },
                jump:  { sy: 78,  w: 84,  h: 120, oy: -120, maxFrame: 4, paddingX: 4, paddingY: 0 }, 
                slide: { sy: 197, w: 129, h: 120, oy: -45, maxFrame: 4, paddingX: 0, paddingY: 0 }, 
                hit:   { sy: 265, w: 90,  h: 80,  oy: -80, maxFrame: 1, paddingX: 0, paddingY: 0 }, 
                dead:  { sy: 265, w: 90,  h: 80,  oy: -80, maxFrame: 3, paddingX: 0, paddingY: 0 }  
            };
        }

        update(deltaTime) {
            if (isPaused) return;
            this.vy += GRAVITY;
            this.y += this.vy;

            if (this.y >= GROUND_Y) { 
                this.y = GROUND_Y; this.vy = 0; this.isGrounded = true; this.jumpCount = 0;
                if (!this.invincible && this.state === 'jump' && this.state !== 'dead') {
                    this.state = 'run';
                }
            } else {
                this.isGrounded = false;
            }

            if (this.state === 'dead') {
            } else if (this.invincible && this.state === 'hit') {
            } else if (this.state === 'slide') {
                 if (!keys.ArrowDown && this.frameX >= this.animConfig.slide.maxFrame - 1) {
                     this.state = 'run';
                }
            } else if (!this.isGrounded) {
                this.state = 'jump';
            } else {
                if (keys.ArrowDown) this.state = 'slide';
                else this.state = 'run';
            }

            if (this.invincible) {
                this.invincibleTimer -= deltaTime;
                if (this.invincibleTimer <= 0) {
                    this.invincible = false;
                    if (this.state === 'hit') this.state = this.isGrounded ? 'run' : 'jump';
                }
            }
            this.animate(deltaTime);
        }

        animate(deltaTime) {
            if (isPaused) return;
            const config = this.animConfig[this.state];
            let currentInterval = this.frameInterval;
            if (this.state === 'dead') currentInterval = 500; 

            if (this.frameTimer > currentInterval) {
                this.frameX++;
                if (this.state === 'dead') {
                    if (this.frameX >= config.maxFrame) this.frameX = config.maxFrame - 1; 
                } else {
                    if (this.frameX >= config.maxFrame) this.frameX = 0; 
                }
                this.frameTimer = 0;
            } else {
                this.frameTimer += deltaTime;
            }
        }

        draw(ctx) {
            if (this.invincible && Math.floor(Date.now() / 100) % 2 === 0 && this.state !== 'dead') return;
            let currentState = this.state;
            let currentFrame = this.frameX;
            if (this.state === 'dead') currentState = 'dead';
            const config = this.animConfig[currentState];
            if (!config) return;

            const sprite = new Sprite(charImg);
            const padX = config.paddingX || 0;
            const padY = config.paddingY || 0;
            const srcX = (currentFrame * config.w) + (padX / 2);
            const srcY = config.sy + (padY / 2);
            const srcW = config.w - padX;
            const srcH = config.h - padY;
            const destX = this.x;
            const destY = this.y + config.oy;
            const destW = config.w * this.scale;
            const destH = config.h * this.scale;

            sprite.draw(ctx, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
        }

        jump() {
            if (this.state === 'dead' || isPaused) return;
            if (this.jumpCount < 2) {
                playSound('jump');
                this.vy = -12;
                if (!this.invincible) {
                    this.state = 'jump';
                    this.frameX = 0;
                }
                this.jumpCount++;
                this.isGrounded = false;
                createParticles(this.x + 30, this.y, 5, '#fff'); 
            }
        }

        slide() {
            if (this.state === 'dead' || isPaused) return;
            if (!this.invincible) {
                this.state = 'slide';
                if (this.isGrounded) this.frameX = 0;
            }
            if (!this.isGrounded) this.vy += 5; 
        }

        hit() {
            if (this.invincible || this.state === 'dead') return;
            playSound('hit'); 
            lives--;
            updateLives();
            if (lives <= 0) {
                this.die();
            } else {
                this.invincible = true;
                this.invincibleTimer = 1500;
                this.state = 'hit'; 
                this.frameX = 0;    
                this.vy = -5;       
                createParticles(this.x + 40, this.y - 40, 10, '#ff0000'); 
            }
        }

        die() {
            this.state = 'dead';
            this.frameX = 0; 
            isGameOver = true;
            stopForestRunnerBGM();
            stopBossBattleBGM();
            createParticles(this.x + 40, this.y - 40, 20, '#ff0000');
            setTimeout(() => {
                showEndScreen("GAME OVER", "#ff4444");
            }, 2500);
        }

        getHitbox() {
            let w = 30; let h = 50; let xOffset = 20; let yOffset = -h; 
            if (this.state === 'slide') { 
                w = 50; h = 25; xOffset = 30; yOffset = -h + 10; 
            } 
            else if (this.state === 'jump') { w = 30; h = 40; yOffset = -h - 10; }
            return { x: this.x + xOffset, y: this.y + yOffset, w: w, h: h };
        }
    }

    class Obstacle {
        constructor(type) {
            this.type = type;
            this.w = 50; this.h = 50; this.x = GAME_WIDTH;
            this.markedForDeletion = false;
            this.color = '#8B4513';
            this.rotation = 0;

            if (this.type === 'ground') {
                this.y = GROUND_Y - 60; 
                this.w = 60; this.h = 60;
            } else {
                const patterns = [75, 85, 95]; 
                this.y = GROUND_Y - patterns[Math.floor(Math.random() * patterns.length)]; 
                this.w = 50; this.h = 50;
            }
        }

        update() {
            if (isPaused) return;
            this.x -= gameSpeed;
            if (this.type === 'air') this.rotation += 0.2; 
            if (this.x < -this.w) this.markedForDeletion = true;
        }

        draw(ctx) {
            if (this.type === 'ground') {
                if (enemyImg.complete) ctx.drawImage(enemyImg, this.x, this.y, this.w, this.h);
                else { ctx.fillStyle = "purple"; ctx.fillRect(this.x, this.y, this.w, this.h); }
            } else {
                if (airObsImg.complete) {
                    ctx.save();
                    ctx.translate(this.x + this.w/2, this.y + this.h/2);
                    ctx.rotate(this.rotation);
                    ctx.drawImage(airObsImg, -this.w/2, -this.h/2, this.w, this.h);
                    ctx.restore();
                } else {
                    ctx.save();
                    ctx.translate(this.x + this.w/2, this.y + this.h/2);
                    ctx.rotate(this.rotation);
                    ctx.fillStyle = '#607D8B';
                    ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);
                    ctx.restore();
                }
            }
        }
        
        getHitbox() {
            return { x: this.x + 10, y: this.y + 10, w: this.w - 20, h: this.h - 20 };
        }
    }

    class Coin {
        constructor() {
            this.size = 24; 
            this.x = GAME_WIDTH;
            this.y = Math.random() > 0.5 ? GROUND_Y - 50 : GROUND_Y - 150;
            this.markedForDeletion = false;
            this.angle = 0;
        }

        update() {
            if (isPaused) return;
            this.x -= gameSpeed;
            this.angle -= 0.1; 
            if (this.x < -this.size) this.markedForDeletion = true;
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x + this.size/2, this.y + this.size/2);
            ctx.rotate(this.angle);
            const r = this.size / 2;
            ctx.beginPath(); ctx.arc(0, 0, r, Math.PI, 0); ctx.fillStyle = "#FF0000"; ctx.fill();
            ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI); ctx.fillStyle = "#FFFFFF"; ctx.fill();
            ctx.beginPath(); ctx.rect(-r, -2, r*2, 4); ctx.fillStyle = "#000000"; ctx.fill();
            ctx.beginPath(); ctx.arc(0, 0, r/3, 0, Math.PI*2); ctx.fillStyle = "#FFFFFF"; ctx.strokeStyle = "#000000"; ctx.lineWidth = 2; ctx.fill(); ctx.stroke();
            ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.strokeStyle = "#000000"; ctx.lineWidth = 2; ctx.stroke();
            ctx.restore();
        }
        
        getHitbox() {
            return { x: this.x, y: this.y, w: this.size, h: this.size };
        }
    }

    class Background {
        constructor() { this.x = 0; this.width = 0; this.height = GAME_HEIGHT; }
        draw(ctx) {
            if (!bgImg.complete) return;
            const scale = GAME_HEIGHT / bgImg.height; 
            const scaledWidth = bgImg.width * scale;
            if (!isPaused) this.x -= gameSpeed * 0.5;
            if (this.x <= -scaledWidth) this.x = 0;
            ctx.drawImage(bgImg, this.x, 0, scaledWidth, GAME_HEIGHT);
            ctx.drawImage(bgImg, this.x + scaledWidth, 0, scaledWidth, GAME_HEIGHT);
            if (scaledWidth * 2 < GAME_WIDTH) ctx.drawImage(bgImg, this.x + scaledWidth * 2, 0, scaledWidth, GAME_HEIGHT);
        }
    }

    const player = new Player();
    const background = new Background();
    let obstacles = [];
    let coins = [];
    let obstacleTimer = 0;
    let coinTimer = 0;
    let lastTime = 0;

    const btnJump = document.getElementById('btnJump');
    const btnSlide = document.getElementById('btnSlide');

    btnJump.addEventListener('mousedown', (e) => { e.preventDefault(); if (!isPlaying && !isGameOver) return; player.jump(); keys.Space = true; btnJump.classList.add('active'); });
    btnJump.addEventListener('mouseup', (e) => { e.preventDefault(); keys.Space = false; btnJump.classList.remove('active'); });
    btnJump.addEventListener('touchstart', (e) => { e.preventDefault(); if (!isPlaying && !isGameOver) return; player.jump(); keys.Space = true; btnJump.classList.add('active'); });
    btnJump.addEventListener('touchend', (e) => { e.preventDefault(); keys.Space = false; btnJump.classList.remove('active'); });

    btnSlide.addEventListener('mousedown', (e) => { e.preventDefault(); if (!isPlaying && !isGameOver) return; keys.ArrowDown = true; player.slide(); btnSlide.classList.add('active'); });
    btnSlide.addEventListener('mouseup', (e) => { e.preventDefault(); keys.ArrowDown = false; btnSlide.classList.remove('active'); });
    btnSlide.addEventListener('touchstart', (e) => { e.preventDefault(); if (!isPlaying && !isGameOver) return; keys.ArrowDown = true; player.slide(); btnSlide.classList.add('active'); });
    btnSlide.addEventListener('touchend', (e) => { e.preventDefault(); keys.ArrowDown = false; btnSlide.classList.remove('active'); });

    window.addEventListener('keydown', e => {
        if (isPaused) return;
        if (!isPlaying && !isGameOver && (e.code === 'Space' || e.code === 'ArrowDown')) return;
        if (e.code === 'Space') { e.preventDefault(); player.jump(); keys.Space = true; }
        if (e.code === 'ArrowDown') { e.preventDefault(); keys.ArrowDown = true; player.slide(); }
    });

    window.addEventListener('keyup', e => {
        if (e.code === 'Space') keys.Space = false;
        if (e.code === 'ArrowDown') keys.ArrowDown = false;
    });

    function checkCollision(rect1, rect2) {
        return (rect1.x < rect2.x + rect2.w && rect1.x + rect1.w > rect2.x && rect1.y < rect2.y + rect2.h && rect1.y + rect1.h > rect2.y);
    }

    function updateLives() {
        let hearts = "";
        for (let i = 0; i < lives; i++) hearts += "â¤ï¸";
        document.getElementById('livesDisplay').innerText = hearts;
    }

    function showFeedback(text, color) {
        const msg = document.getElementById('feedbackMsg');
        msg.innerText = text;
        msg.style.color = color;
        msg.style.display = 'block';
        msg.style.animation = 'none';
        msg.offsetHeight; 
        msg.style.animation = 'popUp 0.8s forwards';
        setTimeout(() => { msg.style.display = 'none'; }, 800);
    }

    function checkQuiz() {
        if (isGameOver || isPaused) return;
        if (quizCount >= MAX_QUIZ_COUNT) return;
        const now = Date.now();
        if (now - lastQuizTime > 10000) { 
            isPaused = true;
            showQuizModal();
        }
    }

    function showQuizModal() {
        const modal = document.getElementById('quizModal');
        const qTitle = document.getElementById('quizTitle');
        const qText = document.getElementById('questionText');
        const qOptions = document.getElementById('quizOptions');
        
        const isFinalBoss = (quizCount === MAX_QUIZ_COUNT - 1);

        if (isFinalBoss) {
            qTitle.innerText = "WARNING! FINAL BOSS";
            qTitle.style.color = "#ff0000";
            qTitle.style.animation = "blink 0.5s infinite";
            stopForestRunnerBGM();
            playBossBattleBGM();
        } else {
            qTitle.innerText = "BONUS QUIZ";
            qTitle.style.color = "#4CAF50";
            qTitle.style.animation = "none";
        }

        const quiz = QUIZ_DATA[quizCount % QUIZ_DATA.length]; 
        qText.innerText = (quizCount + 1) + ". " + quiz.q;
        qOptions.innerHTML = ""; 
        
        quiz.o.forEach((opt, idx) => {
            const btn = document.createElement('div');
            btn.className = 'option-btn';
            btn.innerText = opt;
            btn.onclick = () => handleQuizAnswer(idx === quiz.a, quiz.q);
            qOptions.appendChild(btn);
        });
        
        modal.style.display = 'block';
    }

    function handleQuizAnswer(isCorrect, question) {
        const modal = document.getElementById('quizModal');
        modal.style.display = 'none';
        isPaused = false;
        lastQuizTime = Date.now();
        
        // ê²°ê³¼ ê¸°ë¡
        quizResults.push({ q: question, result: isCorrect });
        
        quizCount++;
        document.getElementById('quizProgress').innerText = `QUIZ: ${quizCount}/${MAX_QUIZ_COUNT}`;

        if (isCorrect) {
            score += 100;
            showFeedback("CORRECT! +100", "#4CAF50");
            player.invincible = true;
            player.invincibleTimer = 1000;
        } else {
            lives--;
            updateLives();
            showFeedback("WRONG! LIFE -1", "#ff4444");
            player.invincible = true; 
            player.invincibleTimer = 1000;
            player.state = 'hit'; 
            player.frameX = 0;
            if (lives <= 0) { player.die(); return; }
        }
        updateUI();
        
        if (quizCount >= MAX_QUIZ_COUNT) { gameClear(); } 
        else { lastTime = performance.now(); requestAnimationFrame(gameLoop); }
    }
    
    function gameClear() {
        isGameOver = true;
        isPlaying = false;
        stopForestRunnerBGM();
        stopBossBattleBGM();
        for(let i=0; i<50; i++) {
            createParticles(Math.random()*GAME_WIDTH, Math.random()*GAME_HEIGHT, 10, ["#f00","#0f0","#00f","#ff0"][Math.floor(Math.random()*4)]);
        }
        showEndScreen("GAME CLEAR!", "#4CAF50");
    }

    function showEndScreen(title, color) {
        const screen = document.getElementById('endScreen');
        screen.classList.remove('hidden');
        document.getElementById('endTitle').innerText = title;
        document.getElementById('endTitle').style.color = color;
        document.getElementById('finalScore').innerText = "FINAL SCORE: " + Math.floor(score);
        
        // í€´ì¦ˆ ê²°ê³¼ ë¦¬í¬íŠ¸ ìƒì„±
        const reportContainer = document.getElementById('quizReport');
        const total = quizResults.length;
        const correct = quizResults.filter(r => r.result).length;
        const wrong = total - correct;
        
        let reportHTML = `<div class="report-summary">
            ì´ ${total}ë¬¸ì œ ì¤‘ <span class="report-correct">${correct} ì •ë‹µ</span> / <span class="report-wrong">${wrong} ì˜¤ë‹µ</span>
        </div>`;
        
        quizResults.forEach((res, index) => {
            const statusClass = res.result ? "report-correct" : "report-wrong";
            const statusText = res.result ? "O" : "X";
            reportHTML += `
            <div class="report-item">
                <span style="width: 85%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${index + 1}. ${res.q}</span>
                <span class="${statusClass}" style="width: 15%; text-align: right; font-weight: bold;">${statusText}</span>
            </div>`;
        });
        
        reportContainer.innerHTML = reportHTML;
        screen.style.display = 'flex';
    }
    
    function updateUI() {
        document.getElementById('scoreDisplay').innerText = "SCORE: " + Math.floor(score);
    }

    function drawSpeechBubble(ctx, x, y) {
        ctx.save();
        const bubbleX = x - 350;
        const bubbleY = y + 20;
        const bubbleW = 320;
        const bubbleH = 60;
        const radius = 10;

        ctx.beginPath();
        ctx.moveTo(bubbleX + radius, bubbleY);
        ctx.lineTo(bubbleX + bubbleW - radius, bubbleY);
        ctx.arcTo(bubbleX + bubbleW, bubbleY, bubbleX + bubbleW, bubbleY + radius, radius);
        ctx.lineTo(bubbleX + bubbleW, bubbleY + bubbleH - radius);
        ctx.arcTo(bubbleX + bubbleW, bubbleY + bubbleH, bubbleX + bubbleW - radius, bubbleY + bubbleH, radius);
        ctx.lineTo(bubbleX + radius, bubbleY + bubbleH);
        ctx.arcTo(bubbleX, bubbleY + bubbleH, bubbleX, bubbleY + bubbleH - radius, radius);
        ctx.lineTo(bubbleX, bubbleY + radius);
        ctx.arcTo(bubbleX, bubbleY, bubbleX + radius, bubbleY, radius);
        ctx.closePath();
        
        ctx.fillStyle = 'white';
        ctx.fill();
        ctx.lineWidth = 3;
        ctx.strokeStyle = 'black';
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(bubbleX + bubbleW, bubbleY + bubbleH / 2);
        ctx.lineTo(bubbleX + bubbleW + 20, bubbleY + bubbleH / 2 + 10);
        ctx.lineTo(bubbleX + bubbleW, bubbleY + bubbleH / 2 + 20);
        ctx.closePath();
        ctx.fillStyle = 'white';
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = 'black';
        ctx.font = "12px 'Press Start 2P', sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("ì²´ìœ¡ ì´ë¡  ê³µë¶€ ì¢€ ë” í•´ì•¼ê² êµ°!", bubbleX + bubbleW / 2, bubbleY + bubbleH / 2);
        ctx.restore();
    }

    function gameLoop(timestamp) {
        if (!isPlaying) return;
        const deltaTime = timestamp - lastTime;
        lastTime = timestamp;

        if (!isPaused && !isGameOver) checkQuiz();

        ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        background.draw(ctx);

        if (quizCount === 9) {
             if (bossImg.complete) {
                 const bossX = GAME_WIDTH - 300;
                 const bossY = 50;
                 ctx.drawImage(bossImg, bossX, bossY, 250, 250);
                 drawSpeechBubble(ctx, bossX, bossY);
             }
        }

        if (isPaused) {
            obstacles.forEach(obs => obs.draw(ctx));
            coins.forEach(coin => coin.draw(ctx));
            player.draw(ctx);
            ctx.fillStyle = 'rgba(0,0,0,0.7)'; 
            ctx.fillRect(0,0, GAME_WIDTH, GAME_HEIGHT);
            return;
        }

        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            if (particles[i].size <= 0) {
                particles.splice(i, 1);
                continue;
            }
            particles[i].draw(ctx);
        }

        obstacleTimer += deltaTime;
        if (obstacleTimer > Math.random() * 1500 + 1000) {
            const type = Math.random() < 0.6 ? 'ground' : 'air';
            obstacles.push(new Obstacle(type));
            obstacleTimer = 0;
        }
        
        obstacles.forEach(obs => {
            obs.update();
            obs.draw(ctx);
            if(checkCollision(player.getHitbox(), obs.getHitbox())) {
                if (obs.type === 'ground') {
                    const ph = player.getHitbox();
                    const oh = obs.getHitbox();
                    if (player.vy > 0 && (ph.y + ph.h < oh.y + oh.h * 0.8)) {
                        playSound('stomp'); 
                        createParticles(obs.x + obs.w/2, obs.y + obs.h/2, 10, '#8B4513'); 
                        obs.markedForDeletion = true;
                        player.vy = -10; 
                    } else {
                        player.hit();
                    }
                } else {
                    player.hit();
                }
            }
        });
        obstacles = obstacles.filter(obs => !obs.markedForDeletion);

        coinTimer += deltaTime;
        if (coinTimer > 600) {
            coins.push(new Coin());
            coinTimer = 0;
        }

        coins.forEach(coin => {
            coin.update();
            coin.draw(ctx);
            if(checkCollision(player.getHitbox(), coin.getHitbox())) {
                score += 10;
                coin.markedForDeletion = true;
                playSound('coin');
                createParticles(coin.x + 15, coin.y + 15, 5, '#FFFFFF'); 
            }
        });
        coins = coins.filter(coin => !coin.markedForDeletion);

        player.update(deltaTime);
        player.draw(ctx);

        if (!isGameOver) {
            score += 0.05;
            gameSpeed += 0.001;
            updateUI();
            requestAnimationFrame(gameLoop);
        } else {
             player.draw(ctx);
        }
    }

    function startGame() {
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
        document.getElementById('startScreen').classList.add('hidden');
        resetVariables();
        isPlaying = true;
        lastTime = performance.now();
        lastQuizTime = Date.now();
        playForestRunnerBGM();
        requestAnimationFrame(gameLoop);
    }

    function resetGame() {
        document.getElementById('endScreen').classList.add('hidden');
        resetVariables();
        isPlaying = true;
        lastTime = performance.now();
        lastQuizTime = Date.now();
        playForestRunnerBGM();
        requestAnimationFrame(gameLoop);
    }

    function resetVariables() {
        score = 0;
        lives = 5;
        gameSpeed = 5;
        obstacles = [];
        coins = [];
        particles = [];
        quizResults = []; // ë¦¬ì…‹
        isGameOver = false;
        isPaused = false;
        quizCount = 0;
        player.state = 'run';
        player.y = GROUND_Y;
        player.invincible = false;
        updateLives();
        updateUI();
        document.getElementById('quizProgress').innerText = "QUIZ: 0/10";
    }

    bgImg.onload = () => {
        background.draw(ctx);
    }

</script>
</body>
</html>